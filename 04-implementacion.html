<!DOCTYPE html>

<html lang="en">
<!--[if lt IE 9]>
        <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
    <![endif]-->
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://juanradam.github.io/FileMonitoringSystem/04-implementacion.html" rel="canonical"/>
<link href="img/favicon.ico" rel="shortcut icon"/>
<title>Implementaci√≥n (GIT) - File Monitoring System</title>
<link href="css/theme.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" rel="stylesheet"/>
<script defer="" src="js/theme.js"></script>
<script> var base_url = "." </script>
<script defer="" src="search/main.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
<header class="header">
<a class="pizza" id="nav-toggle">‚ò∞</a>
<div class="title">
<a class="logo" href="/">File Monitoring System </a>
<div class="search" role="search">
<form><input id="mkdocs-search-query" placeholder="Search docs" type="search"/></form>
</div>
</div>
<a class="scrh" id="nav-scrh">‚åï</a>
</header>
<div class="side" id="side">
<h2>Page</h2>
<ul>
<!--
-->
<li>
<a href="index.html">Home</a>
</li>
<!--
-->
<li>
<a href="01-introduccion.html">Introducci√≥n</a>
</li>
<!--
-->
<li>
<a href="02-requisitos.html">Especificaci√≥n de Requisitos</a>
</li>
<!--
-->
<li>
<a href="03-diseno.html">Dise√±o (Diagramas)</a>
</li>
<!--
-->
<li class="active">
<a href="04-implementacion.html">Implementaci√≥n (GIT)</a>
</li>
<!--
-->
<li>
<a href="05-resultado.html">Resultado (Manual de usuario)</a>
</li>
<!--
-->
<li>
<a href="06-conclusiones.html">Conclusiones</a>
</li>
</ul>
<h2>Table Of Contents</h2>
<ul class="current" id="toc">
<li><a href="#4-implementacion-git">4. Implementaci√≥n (GIT)</a></li>
<li class="child"><a href="#41-diagrama-de-arquitectura">4.1 Diagrama de arquitectura</a></li>
<li class="child"><a href="#42-tecnologias">4.2 Tecnolog√≠as</a></li>
<li class="child"><a href="#43-codigo-explicacion-de-las-partes-mas-interesantes">4.3 C√≥digo (Explicaci√≥n de las partes m√°s interesantes)</a></li>
<li class="child"><a href="#44-organizacion-del-proyecto-patron">4.4 Organizaci√≥n del proyecto. Patr√≥n</a></li>
</ul>
<div class="about">
<hr/>
            Built with üõ† <a href="https://www.mkdocs.org">MkDocs</a> - 
            Theme üñ§ <a href="https://github.com/g3xx/mkdocs-github">Github</a>.
        </div>
</div>
<div class="spacer"><!-- i am margin --></div>
<div class="markdown-body">
<div class="prev">
<a href="03-diseno.html" title="Dise√±o (Diagramas)">‚Üê Previous Page</a>
</div>
<div class="next">
<a href="05-resultado.html" title="Resultado (Manual de usuario)"></a>Next Page ‚Üí
</div>
<div class="clear"></div>
<div id="mkdocs-search-results"></div>
<div id="body">
<h2 id="4-implementacion-git">4. Implementaci√≥n (GIT)<a class="headerlink" href="#4-implementacion-git" title="Permanent link">¬∂</a></h2>
<h3 id="41-diagrama-de-arquitectura">4.1 Diagrama de arquitectura<a class="headerlink" href="#41-diagrama-de-arquitectura" title="Permanent link">¬∂</a></h3>
<div class="mermaid">---
config:
  layout: dagre
---
flowchart LR
  subgraph Usuario["Usuario"]
        Browser["User Browser"]
  end
  subgraph Frontend["Frontend"]
        React["React SPA&lt;br&gt;(Web App)"]
  end
  subgraph API["API"]
        FastAPI["FastAPI Backend&lt;br&gt;(Python)"]
  end
  subgraph Persistencia["Persistencia"]
        Postgres["PostgreSQL DB"]
        HDFS["HDFS Cluster"]
  end
  subgraph Procesamiento["Procesamiento"]
        SparkMaster["üî∑ Spark Master"]
        SparkWorker1["üî∂ Spark Worker 1"]
        SparkWorker2["üî∂ Spark Worker 2"]
        ValidationEngine["Validation Engine&lt;br&gt;(Scala + Spark)"]
  end
  subgraph subGraph7["Contenedores Docker"]
        Superset["Superset BI"]
  end

  Browser -- HTTP requests --&gt; React
  React -- REST/GraphQL&lt;br&gt;JSON over HTTP --&gt; FastAPI
  FastAPI -- SQLAlchemy (INSERT/SELECT/UPDATE) --&gt; Postgres
  FastAPI -- WebHDFS / HDFS Client --&gt; HDFS
  FastAPI -- SELECT * FROM TABLE --&gt; Postgres
  ValidationEngine -- Leer CSV/Parquet --&gt; HDFS
  ValidationEngine -- INSERT logs en trigger_control --&gt; Postgres
  ValidationEngine -- Spark job submission --&gt; SparkMaster
  SparkMaster --&gt; SparkWorker1 &amp; SparkWorker2
  SparkMaster -- HDFS FS Default --- HDFS
  SparkWorker1 -- HDFS FS Default --- HDFS
  SparkWorker2 -- HDFS FS Default --- HDFS
  Superset -- SQLAlchemy --&gt; Postgres

  style Usuario fill:#f9f,stroke:#333,stroke-width:1px
  style Frontend fill:#ccf,stroke:#333,stroke-width:1px
  style API fill:#cfc,stroke:#333,stroke-width:1px
  style Persistencia fill:#ffe599,stroke:#333,stroke-width:1px
  style Procesamiento fill:#f4cccc,stroke:#333,stroke-width:1px</div>
<ul>
<li>
<p><strong>Frontend (React + Vite)</strong></p>
<ul>
<li>Usuario interact√∫a con la UI, llama rutas REST al backend y muestra datos.</li>
<li>
<p><strong>Backend (FastAPI)</strong></p>
</li>
<li>
<p>Exposici√≥n de endpoints <code>/auth</code>, <code>/files</code>, <code>/files/logs</code>.</p>
</li>
<li>Usa <strong>SQLAlchemy Async + AsyncPG</strong> para comunicarse con PostgreSQL.</li>
<li>Utiliza <strong>requests</strong> para llamar a WebHDFS (NameNode/DataNode).</li>
<li>
<p><strong>PostgreSQL</strong></p>
</li>
<li>
<p>Almacena <code>users</code>, <code>file_configuration</code>, <code>trigger_control</code>, <code>negative_flag_logs</code>.</p>
</li>
<li>Superset (opcional) tambi√©n se conecta aqu√≠ para dashboards.</li>
<li>
<p><strong>Motor Scala + Spark</strong></p>
</li>
<li>
<p>Se ejecuta como contenedor independiente, se conecta a HDFS (<code>hdfs://hadoop-namenode:9000</code>).</p>
</li>
<li>Procesa ficheros mediante Spark Streaming en modo batch y escribe logs en PostgreSQL mediante JDBC.</li>
<li>
<p><strong>HDFS (NameNode/DataNode)</strong></p>
</li>
<li>
<p>Almacena CSV en <code>/data/bank_accounts</code>.</p>
</li>
<li>Motor de validaciones lee ficheros desde aqu√≠ y borra tras procesar.</li>
</ul>
</li>
</ul>
<p><em>(Ver <code>docs/diagrama_arquitectura.png</code> para imagen detallada.)</em></p>
<hr/>
<h3 id="42-tecnologias">4.2 Tecnolog√≠as<a class="headerlink" href="#42-tecnologias" title="Permanent link">¬∂</a></h3>
<p>A continuaci√≥n se especifican todas las tecnolog√≠as y dependencias utilizadas en cada componente:</p>
<h4 id="421-motor-de-validaciones-scala-spark">4.2.1 Motor de validaciones (Scala + Spark)<a class="headerlink" href="#421-motor-de-validaciones-scala-spark" title="Permanent link">¬∂</a></h4>
<ul>
<li><strong>Scala 2.12</strong></li>
<li><strong>Apache Spark 3.x</strong></li>
<li><strong>HDFS (Hadoop 3.x)</strong></li>
<li><strong>SBT</strong> (build tool de Scala)</li>
<li><strong>Kryo</strong> (serializaci√≥n para Spark)</li>
<li><strong>Docker</strong> (OpenJDK 11-slim, bitnami/spark)</li>
<li><strong>Docker Compose</strong> (orquestaci√≥n)</li>
</ul>
<h4 id="422-backend-fastapi">4.2.2 Backend (FastAPI)<a class="headerlink" href="#422-backend-fastapi" title="Permanent link">¬∂</a></h4>
<ul>
<li><strong>Python 3.12</strong></li>
<li><strong>FastAPI &gt;= 0.100.0</strong></li>
<li><strong>Uvicorn[standard] &gt;= 0.23.0</strong></li>
<li><strong>SQLAlchemy &gt;= 2.0 (Async)</strong></li>
<li><strong>asyncpg &gt;= 0.28</strong></li>
<li><strong>Pydantic Settings &gt;= 2.0</strong></li>
<li><strong>python-jose &gt;= 3.3</strong></li>
<li><strong>passlib[bcrypt] &gt;= 1.7</strong></li>
<li><strong>requests &gt;= 2.31</strong></li>
<li><strong>python-dotenv &gt;= 1.0</strong></li>
<li><strong>Docker</strong> (para ejecutar contenedores de backend en producci√≥n si se desea)</li>
</ul>
<h4 id="423-frontend-react">4.2.3 Frontend (React)<a class="headerlink" href="#423-frontend-react" title="Permanent link">¬∂</a></h4>
<ul>
<li><strong>React 18+</strong></li>
<li><strong>React Router v6</strong></li>
<li><strong>Axios</strong></li>
<li><strong>Context API</strong> (AuthContext)</li>
<li><strong>Vite</strong></li>
<li><strong>CSS puro</strong></li>
</ul>
<h4 id="424-base-de-datos-y-otros">4.2.4 Base de datos y otros<a class="headerlink" href="#424-base-de-datos-y-otros" title="Permanent link">¬∂</a></h4>
<ul>
<li><strong>PostgreSQL 13</strong></li>
<li><strong>Kafka (opcional)</strong></li>
<li><strong>Zookeeper (opcional)</strong></li>
<li><strong>Superset</strong> (opcional, para dashboards)</li>
<li><strong>PlantUML</strong> (diagramas de referencia)</li>
</ul>
<hr/>
<h3 id="43-codigo-explicacion-de-las-partes-mas-interesantes">4.3 C√≥digo (Explicaci√≥n de las partes m√°s interesantes)<a class="headerlink" href="#43-codigo-explicacion-de-las-partes-mas-interesantes" title="Permanent link">¬∂</a></h3>
<p>Se destacan las implementaciones clave de cada componente.</p>
<h4 id="431-motor-de-validaciones-scala">4.3.1 Motor de validaciones (Scala)<a class="headerlink" href="#431-motor-de-validaciones-scala" title="Permanent link">¬∂</a></h4>
<ol>
<li>
<p><strong><code>SparkSessionProvider.scala</code></strong></p>
<ul>
<li>Configura la <code>SparkSession</code> con par√°metros personalizados:</li>
</ul>
<p><pre class="highlight"><code class="language-scala">val spark = SparkSession.builder()
  .appName("ValidationEngine")
  .master("spark://spark-master:7077")
  .config("spark.serializer", "org.apache.spark.serializer.KryoSerializer")
  .config("spark.kryo.registrator", "com.mycompany.KryoRegistrator")
  .config("spark.hadoop.fs.defaultFS", "hdfs://hadoop-namenode:9000")
  .getOrCreate()</code></pre>
* Ajusta particionamiento y directorios locales a trav√©s de <code>SPARK_LOCAL_DIRS</code>.</p>
</li>
<li>
<p><strong><code>ExecutionManager.scala</code></strong></p>
<ul>
<li>Orquesta todas las validaciones:</li>
</ul>
<p><pre class="highlight"><code class="language-scala">def executeFile(path: String, outputTable: String): Unit = {
  val df = Reader.readFile(spark, path)
  if (!FileSentinel.verifyFiles(df, metadata)) {
    logTrigger(flag, metadata, path)
    return
  }
  if (!TypeValidator.verifyTyping(df, metadata)) {
    logTrigger(flag, metadata, path)
    return
  }
  if (!ReferentialIntegrityValidator.verifyIntegrity(df, metadata)) {
    logTrigger(flag, metadata, path)
    return
  }
  FunctionalValidator.verifyFunctional(df, metadata) match {
    case Some(error) =&gt; 
      logTrigger(errorFlag, metadata, path)
      return
    case None =&gt; 
      logTrigger(2, metadata, path)
  }
  // Registrar en PostgreSQL
  Writer.writeToJdbc(df, outputTable, dbConfig)
  // Borrar de HDFS
  spark.sparkContext.hadoopConfiguration
    .delete(new Path(path), false)
}</code></pre>
* <code>logTrigger(flag, metadata, path)</code>: escribe un DataFrame con columns (<code>logged_at</code>, <code>file_config_id</code>, <code>file_name</code>, <code>field_name</code>, <code>environment</code>, <code>validation_flag</code>, <code>error_message</code>) y hace <code>df.write.mode("append").jdbc(...)</code>.</p>
</li>
<li>
<p><strong>Multi-Stage Dockerfile (<code>docker/Dockerfile.engine</code>)</strong></p>
</li>
</ol>
<pre class="highlight"><code class="language-dockerfile"># Stage 1: Build con OpenJDK y SBT
FROM openjdk:11-slim AS builder
WORKDIR /app

RUN apt-get update &amp;&amp; apt-get install -y curl gnupg &amp;&amp; \
    echo "deb https://repo.scala-sbt.org/scalasbt/debian all main" &gt; /etc/apt/sources.list.d/sbt.list &amp;&amp; \
    curl -sL "https://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0x99E82A75642AC823" | apt-key add - &amp;&amp; \
    apt-get update &amp;&amp; apt-get install -y sbt &amp;&amp; rm -rf /var/lib/apt/lists/*

COPY ../project   project/
COPY ../build.sbt build.sbt
COPY ../src       src/
COPY ../db.properties db.properties
COPY ../src/main/resources/application.conf src/main/resources/

RUN sbt clean assembly

# Stage 2: Runtime Spark
FROM bitnami/spark:3.3.1
WORKDIR /app

COPY --from=builder /app/target/scala-2.12/Fin_de_Grado-assembly-0.1.0-SNAPSHOT.jar app.jar
COPY ../db.properties    db.properties
COPY ../src/main/resources/application.conf application.conf

ENV INPUT_DIR=/data/bank_accounts \
    OUTPUT_TABLE=trigger_control \
    POLL_INTERVAL_MS=10000 \
    SPARK_LOCAL_DIRS=/tmp/spark_local

ENTRYPOINT spark-submit \
  --class Main \
  --master spark://spark-master:7077 \
  --deploy-mode client \
  --conf spark.driver.host=validation-engine \
  --conf spark.hadoop.fs.defaultFS=hdfs://hadoop-namenode:9000 \
  /app/app.jar</code></pre>
<pre class="codehilite"><code>* **Stage 1:** instala SBT, compila fat JAR con todas las dependencias.
* **Stage 2:** parte de una imagen oficial de Spark; copia JAR, `db.properties` y `application.conf`; expone variables de entorno y lanza `spark-submit`.
</code></pre>
<ol>
<li><strong>Script de reconstrucci√≥n (<code>scripts/rebuild_and_run.sh</code>)</strong></li>
</ol>
<pre class="highlight"><code class="language-bash">#!/usr/bin/env bash
set -euo pipefail

# Construir el JAR con SBT
sbt clean assembly

# Crear red si no existe
docker network create superset-net || true

# Reconstruir y ejecutar solo el contenedor de validation-engine
cd docker
docker-compose build validation-engine
docker-compose up --abort-on-container-exit validation-engine</code></pre>
<pre class="codehilite"><code>* Compila el JAR, crea la red `superset-net` y levanta √∫nicamente el contenedor del motor de validaciones (asume que los dem√°s servicios est√°n corriendo).
</code></pre>
<hr/>
<h4 id="432-backend-fastapi">4.3.2 Backend (FastAPI)<a class="headerlink" href="#432-backend-fastapi" title="Permanent link">¬∂</a></h4>
<ol>
<li><strong>Configuraci√≥n (<code>app/core/config.py</code>)</strong></li>
</ol>
<pre class="highlight"><code class="language-python">from pydantic import BaseSettings

class Settings(BaseSettings):
    postgres_user: str
    postgres_password: str
    postgres_host: str
    postgres_port: int
    postgres_db: str

    hdfs_host: str
    hdfs_port: int
    hdfs_dir: str
    hdfs_user: str
    hdfs_datanode_host: str
    hdfs_datanode_port: int

    upload_dir: str
    jwt_secret_key: str
    jwt_algorithm: str
    access_token_expire_minutes: int

    class Config:
        env_file = ".env"</code></pre>
<pre class="codehilite"><code>* Carga variables desde `.env` y construye `database_url = f"postgresql+asyncpg://{user}:{password}@{host}:{port}/{db}"`.
</code></pre>
<ol>
<li><strong>Seguridad (<code>app/core/security.py</code>)</strong></li>
</ol>
<pre class="highlight"><code class="language-python">from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.ext.asyncio import AsyncSession
from .config import Settings
from app.db.models.user import UserModel

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/login")

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def create_access_token(subject: str, expires_delta=None):
    to_encode = {"sub": subject}
    # agregar expiraci√≥n...
    encoded_jwt = jwt.encode(to_encode, Settings().jwt_secret_key, algorithm=Settings().jwt_algorithm)
    return encoded_jwt

async def get_current_user(token: str = Depends(oauth2_scheme), db: AsyncSession = Depends(get_db)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="No autenticado",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, Settings().jwt_secret_key, algorithms=[Settings().jwt_algorithm])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    user = await db.get(UserModel, int(user_id))
    if user is None:
        raise credentials_exception
    return user</code></pre>
<pre class="codehilite"><code>* Define hashing de contrase√±as, creaci√≥n de JWT, y dependencia `get_current_user` que valida el token y extrae `sub`.
</code></pre>
<ol>
<li><strong>Servicio de ficheros (<code>app/services/file_service.py</code>)</strong></li>
</ol>
<pre class="highlight"><code class="language-python">import os
from sqlalchemy.ext.asyncio import AsyncSession
from app.db.models.file_configuration import FileConfigurationModel

async def save_and_register_file(file, db: AsyncSession) -&gt; int:
    upload_dir = Settings().upload_dir
    os.makedirs(upload_dir, exist_ok=True)
    file_path = os.path.join(upload_dir, file.filename)
    with open(file_path, "wb") as f:
        content = await file.read()
        f.write(content)
    result = await db.execute(select(FileConfigurationModel).where(FileConfigurationModel.file_name == file.filename))
    existing = result.scalar_one_or_none()
    if existing:
        # actualizar par√°metros si vienen en request
        existing.some_field = ...
        await db.commit()
        return existing.id
    else:
        new_cfg = FileConfigurationModel(
            file_format="csv",
            path=upload_dir,
            file_name=file.filename,
            has_header=True,
            delimiter=",",
            quote_char='"',
            escape_char="\\",
            date_format="yyyy-MM-dd",
            timestamp_format="yyyy-MM-dd HH:mm:ss",
            partition_columns=None
        )
        db.add(new_cfg)
        await db.flush()
        return new_cfg.id</code></pre>
<pre class="codehilite"><code>* Guarda el CSV en disco local y crea/actualiza el registro en `file_configuration`.
</code></pre>
<ol>
<li><strong>Servicio HDFS (<code>app/services/hdfs_sync.py</code>)</strong></li>
</ol>
<pre class="highlight"><code class="language-python">import requests
from fastapi import HTTPException
from .config import Settings

def push_file_to_hdfs(file_name: str):
    settings = Settings()
    local_path = os.path.join(settings.upload_dir, file_name)
    if not os.path.exists(local_path):
        raise HTTPException(status_code=404, detail=f"Local not found: {local_path}")

    # 1) MKDIRS
    mkdir_url = f"http://{settings.hdfs_host}:{settings.hdfs_port}/webhdfs/v1{settings.hdfs_dir}?op=MKDIRS&amp;user.name={settings.hdfs_user}"
    resp = requests.put(mkdir_url)
    resp.raise_for_status()

    # 2) SETPERM
    perm_url = f"http://{settings.hdfs_host}:{settings.hdfs_port}/webhdfs/v1{settings.hdfs_dir}?op=SETPERM&amp;permission=777&amp;user.name={settings.hdfs_user}"
    resp = requests.put(perm_url)
    resp.raise_for_status()

    # 3) CREATE (NameNode ‚Üí 307 ‚Üí Location ‚Üí DataNode)
    create_url = f"http://{settings.hdfs_host}:{settings.hdfs_port}/webhdfs/v1{settings.hdfs_dir}/{file_name}?op=CREATE&amp;overwrite=true&amp;user.name={settings.hdfs_user}"
    resp = requests.put(create_url, allow_redirects=False)
    location = resp.headers.get("Location")
    if not location:
        raise HTTPException(status_code=500, detail="HDFS create failed: no redirect")
    # Ajustar URL al DataNode
    upload_url = location.replace(f"{settings.hdfs_host}:{settings.hdfs_port}", f"{settings.hdfs_datanode_host}:{settings.hdfs_datanode_port}")
    with open(local_path, "rb") as f:
        resp2 = requests.put(upload_url, data=f)
        resp2.raise_for_status()</code></pre>
<pre class="codehilite"><code>* Gestiona la secuencia WebHDFS (MKDIRS, SETPERM, CREATE ‚Üí 307 ‚Üí PUT a DataNode).
</code></pre>
<ol>
<li><strong>Rutas de archivos (<code>app/api/files.py</code>)</strong></li>
</ol>
<pre class="highlight"><code class="language-python">from fastapi import APIRouter, Depends, UploadFile, File, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from app.services.file_service import save_and_register_file
from app.services.hdfs_sync import push_file_to_hdfs
from app.db.session import get_db

router = APIRouter(prefix="/files", tags=["files"])

@router.post("/upload", status_code=201)
async def upload_file(file: UploadFile = File(...), db: AsyncSession = Depends(get_db)):
    try:
        file_id = await save_and_register_file(file, db)
        return {"file_config_id": file_id}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/push/{file_name}")
async def push_to_hdfs(file_name: str, user=Depends(get_current_user)):
    try:
        push_file_to_hdfs(file_name)
        return {"message": f"Pushed {file_name}"}
    except HTTPException as he:
        raise he
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/")
async def list_configs(db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(FileConfigurationModel))
    configs = result.scalars().all()
    return configs

@router.get("/{id}")
async def get_config(id: int, db: AsyncSession = Depends(get_db)):
    cfg = await db.get(FileConfigurationModel, id)
    if not cfg:
        raise HTTPException(status_code=404, detail="Not found")
    return cfg

@router.patch("/{id}")
async def update_config(id: int, payload: FileConfigUpdate, db: AsyncSession = Depends(get_db)):
    cfg = await db.get(FileConfigurationModel, id)
    if not cfg:
        raise HTTPException(status_code=404, detail="Not found")
    for key, val in payload.dict(exclude_unset=True).items():
        setattr(cfg, key, val)
    await db.commit()
    return cfg

@router.delete("/{id}", status_code=204)
async def delete_config(id: int, db: AsyncSession = Depends(get_db)):
    cfg = await db.get(FileConfigurationModel, id)
    if not cfg:
        raise HTTPException(status_code=404, detail="Not found")
    await db.delete(cfg)
    await db.commit()

@router.get("/download/{file_name}")
async def download_file(file_name: str):
    file_path = os.path.join(Settings().upload_dir, file_name)
    if not os.path.exists(file_path):
        raise HTTPException(status_code=404, detail="File not found")
    return FileResponse(file_path, media_type="text/csv", filename=file_name)

@router.get("/logs")
async def get_logs(environment: str = None, from_date: date = None, to_date: date = None, db: AsyncSession = Depends(get_db)):
    query = select(TriggerControlModel)
    if environment:
        query = query.where(TriggerControlModel.environment == environment)
    if from_date:
        query = query.where(TriggerControlModel.logged_at &gt;= from_date)
    if to_date:
        query = query.where(TriggerControlModel.logged_at &lt;= to_date)
    result = await db.execute(query.order_by(TriggerControlModel.logged_at.desc()))
    logs = result.scalars().all()
    return logs</code></pre>
<pre class="codehilite"><code>* Endpoints para CRUD de configuraciones, subida, push a HDFS, descarga y consulta de logs.
</code></pre>
<hr/>
<h4 id="433-frontend-react-vite">4.3.3 Frontend (React + Vite)<a class="headerlink" href="#433-frontend-react-vite" title="Permanent link">¬∂</a></h4>
<ol>
<li><strong>Configuraci√≥n de Axios (<code>src/api/axiosConfig.js</code>)</strong></li>
</ol>
<pre class="highlight"><code class="language-js">import axios from 'axios';

const api = axios.create({
  baseURL: 'http://localhost:8000',
});

// Interceptor de petici√≥n: a√±ade token si existe
api.interceptors.request.use(config =&gt; {
  const token = localStorage.getItem('access_token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Interceptor de respuesta: si 401, borrar token y redirigir
api.interceptors.response.use(
  response =&gt; response,
  error =&gt; {
    if (error.response &amp;&amp; error.response.status === 401) {
      localStorage.removeItem('access_token');
      alert('Tu sesi√≥n ha expirado. Por favor, inicia sesi√≥n de nuevo.');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default api;</code></pre>
<pre class="codehilite"><code>* Gestiona token en cada petici√≥n y maneja 401 autom√°ticamente.
</code></pre>
<ol>
<li><strong><code>AuthContext.jsx</code></strong></li>
</ol>
<pre class="highlight"><code class="language-jsx">import React, { createContext, useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import api from '../api/axiosConfig';

export const AuthContext = createContext();

export const AuthProvider = ({ children }) =&gt; {
  const [token, setToken] = useState(localStorage.getItem('access_token'));
  const navigate = useNavigate();

  useEffect(() =&gt; {
    if (token) {
      localStorage.setItem('access_token', token);
    } else {
      localStorage.removeItem('access_token');
    }
  }, [token]);

  const login = async (email, password) =&gt; {
    const res = await api.post('/auth/login', { email, password });
    setToken(res.data.access_token);
    navigate('/dashboard');
  };

  const register = async (email, password) =&gt; {
    await api.post('/auth/register', { email, password });
    navigate('/login');
  };

  const logout = () =&gt; {
    setToken(null);
    navigate('/login');
  };

  return (
    &lt;AuthContext.Provider value={{ token, login, register, logout }}&gt;
      {children}
    &lt;/AuthContext.Provider&gt;
  );
};</code></pre>
<pre class="codehilite"><code>* Gestiona estado global de autenticaci√≥n y m√©todos `login()`, `register()`, `logout()`.
</code></pre>
<ol>
<li><strong><code>AppRouter.jsx</code></strong></li>
</ol>
<pre class="highlight"><code class="language-jsx">import React, { useContext } from 'react';
import { BrowserRouter, Routes, Route, Navigate, useLocation } from 'react-router-dom';
import { AuthContext } from '../contexts/AuthContext';
import LoginPage from '../pages/LoginPage';
import RegisterPage from '../pages/RegisterPage';
import Dashboard from '../pages/Dashboard';
import LogsPage from '../pages/LogsPage';
import MainLayout from '../layouts/MainLayout';

const RequireAuth = ({ children }) =&gt; {
  const { token } = useContext(AuthContext);
  const location = useLocation();
  return token ? children : &lt;Navigate to="/login" state={{ from: location }} replace /&gt;;
};

const AppRouter = () =&gt; (
  &lt;BrowserRouter&gt;
    &lt;Routes&gt;
      &lt;Route path="/login" element={&lt;LoginPage /&gt;} /&gt;
      &lt;Route path="/register" element={&lt;RegisterPage /&gt;} /&gt;
      &lt;Route path="/" element={&lt;RequireAuth&gt;&lt;MainLayout /&gt;&lt;/RequireAuth&gt;}&gt;
        &lt;Route index element={&lt;Navigate to="/dashboard" replace /&gt;} /&gt;
        &lt;Route path="dashboard" element={&lt;Dashboard /&gt;} /&gt;
        &lt;Route path="logs" element={&lt;LogsPage /&gt;} /&gt;
      &lt;/Route&gt;
      &lt;Route path="*" element={&lt;Navigate to="/login" replace /&gt;} /&gt;
    &lt;/Routes&gt;
  &lt;/BrowserRouter&gt;
);

export default AppRouter;</code></pre>
<pre class="codehilite"><code>* Define rutas p√∫blicas (`/login`, `/register`) y privadas (`/dashboard`, `/logs`) con `RequireAuth`.
</code></pre>
<ol>
<li><strong><code>Dashboard.jsx</code></strong></li>
</ol>
<pre class="highlight"><code class="language-jsx">import React, { useState, useEffect, useContext } from 'react';
import { AuthContext } from '../contexts/AuthContext';
import api from '../api/axiosConfig';
import FileDetailModal from '../components/FileDetailModal';

const Dashboard = () =&gt; {
  const [configs, setConfigs] = useState([]);
  const [selectedFile, setSelectedFile] = useState(null);
  const [uploading, setUploading] = useState(false);
  const [showModal, setShowModal] = useState(false);
  const [currentConfig, setCurrentConfig] = useState(null);

  const fetchConfigs = async () =&gt; {
    const res = await api.get('/files/');
    setConfigs(res.data);
  };

  useEffect(() =&gt; {
    fetchConfigs();
  }, []);

  const handleUpload = async () =&gt; {
    if (!selectedFile) return;
    setUploading(true);
    const form = new FormData();
    form.append('file', selectedFile);
    const res = await api.post('/files/upload', form);
    alert(`Fichero subido ID: ${res.data.file_config_id}`);
    fetchConfigs();
    setUploading(false);
  };

  const handleValidate = async (fileName) =&gt; {
    await api.post(`/files/push/${fileName}`);
    alert('Enviado a validar');
    fetchConfigs();
  };

  const handleDelete = async (id) =&gt; {
    if (!window.confirm('¬øEst√°s seguro?')) return;
    await api.delete(`/files/${id}`);
    alert('Configuraci√≥n eliminada');
    fetchConfigs();
  };

  return (
    &lt;div&gt;
      &lt;h2&gt;Dashboard&lt;/h2&gt;
      &lt;input type="file" onChange={e =&gt; setSelectedFile(e.target.files[0])} /&gt;
      &lt;button onClick={handleUpload} disabled={uploading}&gt;
        {uploading ? 'Subiendo...' : 'Subir Fichero'}
      &lt;/button&gt;
      &lt;table&gt;
        &lt;thead&gt;
          &lt;tr&gt;
            &lt;th&gt;ID&lt;/th&gt;
            &lt;th&gt;Fichero&lt;/th&gt;
            &lt;th&gt;Has Header&lt;/th&gt;
            &lt;th&gt;Delimiter&lt;/th&gt;
            &lt;th&gt;Acciones&lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
          {configs.map(cfg =&gt; (
            &lt;tr key={cfg.id}&gt;
              &lt;td&gt;{cfg.id}&lt;/td&gt;
              &lt;td&gt;{cfg.file_name}&lt;/td&gt;
              &lt;td&gt;{cfg.has_header ? 'S√≠' : 'No'}&lt;/td&gt;
              &lt;td&gt;{cfg.delimiter}&lt;/td&gt;
              &lt;td&gt;
                &lt;button onClick={() =&gt; handleValidate(cfg.file_name)}&gt;Enviando‚Ä¶&lt;/button&gt;
                &lt;button onClick={() =&gt; { setCurrentConfig(cfg); setShowModal(true); }}&gt;Detalles&lt;/button&gt;
                &lt;button onClick={() =&gt; handleDelete(cfg.id)}&gt;Eliminar&lt;/button&gt;
              &lt;/td&gt;
            &lt;/tr&gt;
          ))}
        &lt;/tbody&gt;
      &lt;/table&gt;
      {showModal &amp;&amp; (
        &lt;FileDetailModal
          config={currentConfig}
          onClose={() =&gt; setShowModal(false)}
          onRefresh={fetchConfigs}
        /&gt;
      )}
    &lt;/div&gt;
  );
};

export default Dashboard;</code></pre>
<pre class="codehilite"><code>* Subida de fichero, lista de configuraciones con acciones (Validar, Detalles, Eliminar).
</code></pre>
<ol>
<li><strong><code>FileDetailModal.jsx</code></strong></li>
</ol>
<pre class="highlight"><code class="language-jsx">import React, { useState } from 'react';
import api from '../api/axiosConfig';

const FileDetailModal = ({ config, onClose, onRefresh }) =&gt; {
  const [delimiter, setDelimiter] = useState(config.delimiter);
  const [quoteChar, setQuoteChar] = useState(config.quote_char);
  const [escapeChar, setEscapeChar] = useState(config.escape_char);
  const [hasHeader, setHasHeader] = useState(config.has_header);
  const [dateFormat, setDateFormat] = useState(config.date_format);
  const [timestampFormat, setTimestampFormat] = useState(config.timestamp_format);
  const [partitionColumns, setPartitionColumns] = useState(config.partition_columns);
  const [saving, setSaving] = useState(false);
  const [validating, setValidating] = useState(false);
  const [deleting, setDeleting] = useState(false);

  const save = async () =&gt; {
    setSaving(true);
    await api.patch(`/files/${config.id}`, {
      delimiter, quote_char: quoteChar, escape_char: escapeChar,
      has_header: hasHeader, date_format: dateFormat,
      timestamp_format: timestampFormat, partition_columns: partitionColumns
    });
    alert('Configuraci√≥n actualizada');
    setSaving(false);
    onClose();
    onRefresh();
  };

  const validate = async () =&gt; {
    setValidating(true);
    await api.post(`/files/push/${config.file_name}`);
    alert('Enviado a validar');
    setValidating(false);
    onClose();
    onRefresh();
  };

  const downloadFile = async () =&gt; {
    const res = await fetch(`http://localhost:8000/files/download/${config.file_name}`, {
      headers: { Authorization: `Bearer ${localStorage.getItem('access_token')}` }
    });
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = config.file_name;
    a.click();
    URL.revokeObjectURL(url);
  };

  const remove = async () =&gt; {
    if (!window.confirm('¬øEst√°s seguro?')) return;
    setDeleting(true);
    await api.delete(`/files/${config.id}`);
    alert('Configuraci√≥n eliminada');
    setDeleting(false);
    onClose();
    onRefresh();
  };

  const overlayStyle = {
    position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
    backgroundColor: 'rgba(0,0,0,0.5)', display: 'flex',
    justifyContent: 'center', alignItems: 'center'
  };
  const modalStyle = {
    background: '#fff', padding: '1rem', borderRadius: '8px',
    position: 'relative', width: '500px'
  };

  return (
    &lt;div style={overlayStyle} onClick={onClose}&gt;
      &lt;div style={modalStyle} onClick={e =&gt; e.stopPropagation()}&gt;
        &lt;h3&gt;Detalles Fichero&lt;/h3&gt;
        &lt;label&gt;Delimiter:&lt;/label&gt;
        &lt;select value={delimiter} onChange={e =&gt; setDelimiter(e.target.value)}&gt;
          &lt;option value=","&gt;Comma&lt;/option&gt;
          &lt;option value=";"&gt;Semicolon&lt;/option&gt;
          &lt;option value="\t"&gt;Tab&lt;/option&gt;
          &lt;option value="|"&gt;Pipe&lt;/option&gt;
        &lt;/select&gt;
        &lt;label&gt;Quote Character:&lt;/label&gt;
        &lt;select value={quoteChar} onChange={e =&gt; setQuoteChar(e.target.value)}&gt;
          &lt;option value={'"'}&gt;Double&lt;/option&gt;
          &lt;option value="'"&gt;Single&lt;/option&gt;
          &lt;option value=""&gt;None&lt;/option&gt;
        &lt;/select&gt;
        &lt;label&gt;Escape Character:&lt;/label&gt;
        &lt;select value={escapeChar} onChange={e =&gt; setEscapeChar(e.target.value)}&gt;
          &lt;option value="\\"&gt;Backslash&lt;/option&gt;
          &lt;option value={'"'}&gt;Double&lt;/option&gt;
          &lt;option value=""&gt;None&lt;/option&gt;
        &lt;/select&gt;
        &lt;label&gt;Has Header:&lt;/label&gt;
        &lt;input type="checkbox" checked={hasHeader} onChange={e =&gt; setHasHeader(e.target.checked)} /&gt;
        &lt;label&gt;Date Format:&lt;/label&gt;
        &lt;select value={dateFormat} onChange={e =&gt; setDateFormat(e.target.value)}&gt;
          &lt;option value="yyyy-MM-dd"&gt;YYYY-MM-DD&lt;/option&gt;
          &lt;option value="dd/MM/yyyy"&gt;DD/MM/YYYY&lt;/option&gt;
          &lt;option value="MM-dd-yyyy"&gt;MM-DD-YYYY&lt;/option&gt;
        &lt;/select&gt;
        &lt;label&gt;Timestamp Format:&lt;/label&gt;
        &lt;select value={timestampFormat} onChange={e =&gt; setTimestampFormat(e.target.value)}&gt;
          &lt;option value="yyyy-MM-dd HH:mm:ss"&gt;YYYY-MM-DD HH:mm:ss&lt;/option&gt;
          &lt;option value="ISO 8601"&gt;ISO 8601&lt;/option&gt;
          &lt;option value="Timestamp MS"&gt;Timestamp MS&lt;/option&gt;
        &lt;/select&gt;
        &lt;label&gt;Partition Columns:&lt;/label&gt;
        &lt;input
          type="text"
          value={partitionColumns || ''}
          onChange={e =&gt; setPartitionColumns(e.target.value)}
        /&gt;
        &lt;div style={{ marginTop: '1rem' }}&gt;
          &lt;button onClick={save} disabled={saving}&gt;
            {saving ? 'Guardando...' : 'Guardar'}
          &lt;/button&gt;
          &lt;button onClick={validate} disabled={validating}&gt;
            {validating ? 'Enviando‚Ä¶' : 'Validar'}
          &lt;/button&gt;
          &lt;button onClick={downloadFile}&gt;Descargar&lt;/button&gt;
          &lt;button onClick={remove} disabled={deleting}&gt;
            {deleting ? 'Eliminando‚Ä¶' : 'Eliminar'}
          &lt;/button&gt;
        &lt;/div&gt;
        &lt;button onClick={onClose} style={{ position: 'absolute', top: '8px', right: '8px' }}&gt;√ó&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

export default FileDetailModal;</code></pre>
<pre class="codehilite"><code>* Modal para editar par√°metros, validar, descargar y eliminar configuraci√≥n.
</code></pre>
<ol>
<li><strong><code>LogsPage.jsx</code></strong></li>
</ol>
<pre class="highlight"><code class="language-jsx">import React, { useState, useEffect } from 'react';
import api from '../api/axiosConfig';

const LogsPage = () =&gt; {
  const [logs, setLogs] = useState([]);

  const fetchLogs = async () =&gt; {
    const res = await api.get('/files/logs');
    setLogs(res.data);
  };

  useEffect(() =&gt; {
    fetchLogs();
  }, []);

  return (
    &lt;div&gt;
      &lt;h2&gt;Logs de Validaci√≥n&lt;/h2&gt;
      &lt;table&gt;
        &lt;thead&gt;
          &lt;tr&gt;
            &lt;th&gt;ID&lt;/th&gt;
            &lt;th&gt;Config ID&lt;/th&gt;
            &lt;th&gt;Fichero&lt;/th&gt;
            &lt;th&gt;Campo&lt;/th&gt;
            &lt;th&gt;Entorno&lt;/th&gt;
            &lt;th&gt;Flag&lt;/th&gt;
            &lt;th&gt;Mensaje&lt;/th&gt;
            &lt;th&gt;Fecha&lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
          {logs.map(l =&gt; (
            &lt;tr key={l.id}&gt;
              &lt;td&gt;{l.id}&lt;/td&gt;
              &lt;td&gt;{l.file_config_id}&lt;/td&gt;
              &lt;td&gt;{l.file_name}&lt;/td&gt;
              &lt;td&gt;{l.field_name}&lt;/td&gt;
              &lt;td&gt;{l.environment}&lt;/td&gt;
              &lt;td&gt;{l.validation_flag}&lt;/td&gt;
              &lt;td&gt;{l.error_message}&lt;/td&gt;
              &lt;td&gt;{new Date(l.logged_at).toLocaleDateString('es-ES')}&lt;/td&gt;
            &lt;/tr&gt;
          ))}
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/div&gt;
  );
};

export default LogsPage;</code></pre>
<pre class="codehilite"><code>* Muestra los logs de validaci√≥n y formatea la fecha a espa√±ol.
</code></pre>
<hr/>
<h3 id="44-organizacion-del-proyecto-patron">4.4 Organizaci√≥n del proyecto. Patr√≥n<a class="headerlink" href="#44-organizacion-del-proyecto-patron" title="Permanent link">¬∂</a></h3>
<p>Se propone la siguiente estructura monol√≠tica (tres carpetas principales), aunque cada componente puede colocarse en repositorios separados seg√∫n conveniencia:</p>
<pre class="highlight"><code>FileMonitoringSystem/
‚îú‚îÄ‚îÄ backend/                            ‚Üê C√≥digo FastAPI
‚îÇ   ‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ files.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ health.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ security.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ db/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ session.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ user.py
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ file_configuration.py
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ semantic_layer.py      ‚Üê metadatos de campos
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ trigger_control.py
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ negative_flag_logs.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ file_service.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ hdfs_sync.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ schemas/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ auth.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ files.py
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ logs.py
‚îÇ   ‚îú‚îÄ‚îÄ main.py
‚îÇ   ‚îú‚îÄ‚îÄ .env
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
‚îÇ   ‚îî‚îÄ‚îÄ test_api.sh
‚îÇ
‚îú‚îÄ‚îÄ frontend/                           ‚Üê C√≥digo React + Vite
‚îÇ   ‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.html
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ axiosConfig.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ FileDetailModal.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ contexts/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AuthContext.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layouts/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ MainLayout.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dashboard.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoginPage.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RegisterPage.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ LogsPage.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AppRouter.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ styles/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.css
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.jsx
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îÇ
‚îú‚îÄ‚îÄ engine/                             ‚Üê Motor de validaciones Scala + Spark
‚îÇ   ‚îú‚îÄ‚îÄ docker/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile.engine
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile.superset
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ docker-compose.yml
‚îÇ   ‚îú‚îÄ‚îÄ docs/                           ‚Üê Diagramas PNG
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ diagrama_casos_de_uso.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ERD.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ diagrama_clases.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ diagrama_secuencia.png
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ rebuild_and_run.sh
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ resources/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application.conf
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ db.properties
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ files/                ‚Üê Scripts Python para generar CSV de prueba
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ scala/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Main.scala
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ DbConfig.scala
‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ DBConnection.scala
‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ SparkSessionProvider.scala
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ FileConfigurationCaseClass.scala
‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ SemanticLayerCaseClass.scala
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ ExecutionManager.scala
‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ TriggerIdManager.scala
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ Reader.scala
‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ Writer.scala
‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ FileManager.scala
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ validators/
‚îÇ   ‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ FileSentinel.scala
‚îÇ   ‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ TypeValidator.scala
‚îÇ   ‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ ReferentialIntegrityValidator.scala
‚îÇ   ‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ FunctionalValidator.scala
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test/scala/                 ‚Üê Pruebas unitarias (ScalaTest)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ build.sbt
‚îÇ   ‚îî‚îÄ‚îÄ README-cluster.md               ‚Üê Gu√≠a de cluster Hadoop/Spark/Kafka/Superset
‚îÇ
‚îú‚îÄ‚îÄ docs/                               ‚Üê Carpeta MkDocs (documentaci√≥n ‚Äúlibro‚Äù)
‚îÇ   ‚îú‚îÄ‚îÄ 01-introduccion.md
‚îÇ   ‚îú‚îÄ‚îÄ 02-requisitos.md
‚îÇ   ‚îú‚îÄ‚îÄ 03-diseno.md
‚îÇ   ‚îú‚îÄ‚îÄ 04-implementacion.md
‚îÇ   ‚îú‚îÄ‚îÄ 05-resultado.md
‚îÇ   ‚îú‚îÄ‚îÄ 06-conclusiones.md
‚îÇ   ‚îî‚îÄ‚îÄ img/
‚îÇ       ‚îú‚îÄ‚îÄ diagrama_casos_de_uso.png
‚îÇ       ‚îú‚îÄ‚îÄ ERD.png
‚îÇ       ‚îú‚îÄ‚îÄ diagrama_clases.png
‚îÇ       ‚îú‚îÄ‚îÄ diagrama_secuencia.png
‚îÇ       ‚îî‚îÄ‚îÄ ... (otros PNG)
‚îÇ
‚îú‚îÄ‚îÄ mkdocs.yml                          ‚Üê Configuraci√≥n de MkDocs
‚îú‚îÄ‚îÄ .github/
‚îÇ   ‚îî‚îÄ‚îÄ workflows/
‚îÇ       ‚îî‚îÄ‚îÄ mkdocs-deploy.yml           ‚Üê GitHub Action para desplegar en Pages
‚îÇ
‚îî‚îÄ‚îÄ README-cluster.md                   ‚Üê Gu√≠a de cluster (si quieres)  </code></pre>
<ul>
<li>El patr√≥n es <strong>feature-based</strong>: cada carpeta agrupa archivos seg√∫n responsabilidad (API, servicios, modelos, diagramas, etc.).</li>
<li>Cada componente puede versionarse por separado y luego combinarse en un monorepo si se desea.</li>
</ul>
<hr/>
</div>
<hr/>
<!--
  MkDocs version      : 1.6.1
  Docs Build Date UTC : 2025-06-11 15:25:00.974720+00:00
  -->
</div>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>